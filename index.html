<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Browser LLM Chat Demo</title>
    <style>
      body {
        font-family: Inter, system-ui, -apple-system, sans-serif;
        background-color: #f9fafb;
        color: #111827;
        line-height: 1.6;
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
      }

      .app-container {
        background-color: white;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        padding: 2rem;
        overflow: hidden;
        margin-top: 5rem;
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        margin: 0;
        color: #111827;
      }

      .settings-button {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        color: #374151;
        width: auto;
        padding: 0.6rem;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.15s;
      }

      .settings-button:hover {
        background: #f3f4f6;
        border-color: #d1d5db;
      }

      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }

      .modal-overlay.show {
        display: flex;
      }

      .modal {
        background: white;
        border-radius: 16px;
        padding: 2rem;
        max-width: 400px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }

      .modal-title {
        font-size: 1.2rem;
        font-weight: 600;
        margin: 0;
        color: #111827;
      }

      .close-button {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: #6b7280;
        padding: 0.25rem;
        width: auto;
        border-radius: 4px;
      }

      .close-button:hover {
        background: #f3f4f6;
        color: #374151;
      }

      .form-field {
        margin-bottom: 1rem;
      }

      .form-label {
        display: block;
        font-weight: 500;
        margin-bottom: 0.5rem;
        color: #374151;
        font-size: 0.9rem;
      }

      .form-input {
        width: 100%;
        padding: 0.75rem;
        border: 1px solid #d1d5db;
        border-radius: 8px;
        font-size: 0.9rem;
        transition: border-color 0.15s;
      }

      .form-input:focus {
        outline: none;
        border-color: #6b7280;
        box-shadow: 0 0 0 1px rgba(107, 114, 128, 0.1);
      }

      .form-input[type="number"] {
        -moz-appearance: textfield;
      }

      .form-input[type="number"]::-webkit-outer-spin-button,
      .form-input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      .form-input-wrapper {
        position: relative;
        display: flex;
        align-items: center;
      }

      .form-input-wrapper .form-input {
        padding-right: 2.5rem;
      }

      .toggle-password {
        position: absolute;
        right: 0.75rem;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        cursor: pointer;
        color: #6b7280;
        padding: 0.25rem;
        width: auto;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toggle-password:hover {
        background: #f3f4f6;
        color: #374151;
      }

      .button-group {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.5rem;
        flex-wrap: wrap;
      }

      .button-group button {
        flex: 1;
        min-width: 120px;
      }

      .button-secondary {
        background: #f9fafb;
        color: #374151;
        border: 1px solid #d1d5db;
      }

      .button-secondary:hover:not(:disabled) {
        background: #f3f4f6;
        border-color: #9ca3af;
      }

      .button-danger {
        background: #dc2626;
        color: white;
        border: 1px solid #dc2626;
      }

      .button-danger:hover:not(:disabled) {
        background: #b91c1c;
        border-color: #b91c1c;
      }

      /* Toast Notifications */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: none;
      }

      .toast {
        background: white;
        border-radius: 12px;
        padding: 1rem 1.25rem;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        border-left: 4px solid #10b981;
        max-width: 400px;
        pointer-events: auto;
        transform: translateX(100%);
        opacity: 0;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        font-size: 0.9rem;
      }

      .toast.show {
        transform: translateX(0);
        opacity: 1;
      }

      .toast.success {
        border-left-color: #10b981;
      }

      .toast.error {
        border-left-color: #ef4444;
      }

      .toast.warning {
        border-left-color: #f59e0b;
      }

      .toast.info {
        border-left-color: #3b82f6;
      }

      .toast-icon {
        flex-shrink: 0;
        width: 20px;
        height: 20px;
      }

      .toast-content {
        flex: 1;
        line-height: 1.4;
      }

      .toast-close {
        background: none;
        border: none;
        color: #6b7280;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        flex-shrink: 0;
      }

      .toast-close:hover {
        background: #f3f4f6;
        color: #374151;
      }

      #output {
        background: transparent;
        padding: 1.25rem;
        min-height: 220px;
        border-radius: 12px;
        white-space: pre-wrap;
        overflow-y: auto;
        max-height: 420px;
        font-size: 0.95rem;
        transition: min-height 0.3s ease;
      }

      #output.compact {
        min-height: 80px;
      }

      .chat-container.compact {
        gap: 1rem;
      }

      #user-input-bubble {
        background: #000000;
        border: 1px solid #e0e0e0;
        padding: 1rem;
        border-radius: 12px;
        margin-bottom: 1rem;
        display: none;
        animation: fadeIn 0.3s ease-in;
      }

      #user-input-bubble.show {
        display: block;
      }

      #user-input-header {
        font-weight: 600;
        color: #efefef;
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
      }

      #user-input-content {
        color: #ffffff;
        font-size: 0.95rem;
        white-space: pre-wrap;
      }

      .thinking-indicator {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #6b7280;
        /* font-style: italic; */
        background: #f9fafb;
        padding: 0.75rem 1rem;
        border-radius: 12px;
        margin: 0.5rem 0;
        border: 1px solid #e5e7eb;
      }

      .thinking-dots {
        display: flex;
        gap: 0.25rem;
      }

      .thinking-dot {
        width: 6px;
        height: 6px;
        background: #9ca3af;
        border-radius: 50%;
        animation: thinkingPulse 1.4s infinite ease-in-out;
      }

      .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
      .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
      .thinking-dot:nth-child(3) { animation-delay: 0s; }

      @keyframes thinkingPulse {
        0%, 80%, 100% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        40% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .assistant-response {
        line-height: 1.7;
      }

      .assistant-response h1, .assistant-response h2, .assistant-response h3,
      .assistant-response h4, .assistant-response h5, .assistant-response h6 {
        font-weight: 600;
        margin: 1rem 0 0.5rem 0;
        color: #111827;
      }

      .assistant-response h1 { font-size: 1.5rem; }
      .assistant-response h2 { font-size: 1.3rem; }
      .assistant-response h3 { font-size: 1.1rem; }

      .assistant-response p {
        margin: 0.3rem 0;
      }

      .assistant-response p:first-child {
        margin-top: 0;
      }

      .assistant-response p:last-child {
        margin-bottom: 0;
      }

      .assistant-response ul, .assistant-response ol {
        margin: 0.3rem 0;
        padding-left: 1.5rem;
      }

      .assistant-response li {
        margin: 0.1rem 0;
        line-height: 1.4;
      }

      .assistant-response code {
        background: #f3f4f6;
        padding: 0.125rem 0.25rem;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
      }

      .assistant-response pre {
        background: #f8fafc;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 1rem;
        overflow-x: auto;
        margin: 1rem 0;
      }

      .assistant-response pre code {
        background: none;
        padding: 0;
      }

      .assistant-response blockquote {
        border-left: 4px solid #e5e7eb;
        margin: 0.3rem 0;
        padding-left: 1rem;
        color: #6b7280;
      }

      .assistant-response strong {
        font-weight: 600;
      }

      .assistant-response em {
        font-style: italic;
      }

      .assistant-response table {
        border-collapse: collapse;
        margin: 1rem 0;
        width: 100%;
      }

      .assistant-response th, .assistant-response td {
        border: 1px solid #e5e7eb;
        padding: 0.5rem;
        text-align: left;
      }

      .assistant-response th {
        background: #f9fafb;
        font-weight: 600;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(-10px); }
      }

      .fade-out {
        animation: fadeOut 0.3s ease-out forwards;
      }

      input,
      button,
      select {
        font-family: inherit;
        font-size: 0.95rem;
        padding: 0.8rem 1rem;
        width: 100%;
        border-radius: 10px;
        border: 1px solid #000000;
        background-color: white;
        transition: opacity 0.15s;
      }

      input:disabled {
        opacity: 0.2;
      }

      button {
        background-color: #000000;
        color: white;
        border: 1px solid #000000;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
      }

      button:hover:not(:disabled) {
        background-color: #ffffff;
        color: #000000;
        border: 1px solid #000000;
      }

      button:disabled {
        background-color: #000000;
        color: white;
        border: 1px solid #000000;
        opacity: 0.2;
        cursor: not-allowed;
      }

      .error {
        color: #dc2626;
        background-color: #fee2e2;
        padding: 0.8rem;
        border-radius: 10px;
        margin-top: 0.75rem;
        font-size: 0.9rem;
      }



      .chat-container {
        margin-top: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .progress-container {
        margin-top: 1rem;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background-color: #e5e7eb;
        border-radius: 999px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background-color: #050505;
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        font-size: 0.8rem;
        text-align: center;
        margin-top: 0.5rem;
        color: #6b7280;
      }

      .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      input {
        box-sizing: border-box;
        margin: 0rem;
      }

      input:focus,
      select:focus {
        outline: none;
        border-color: rgba(0, 0, 0, 0.5);
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <div class="header">
        <h1>Ask your Voiceflow Knowledge Base</h1>
        <button class="settings-button" id="settings-button" title="Settings">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 15.5A3.5 3.5 0 0 1 8.5 12A3.5 3.5 0 0 1 12 8.5a3.5 3.5 0 0 1 3.5 3.5 3.5 3.5 0 0 1-3.5 3.5m7.43-2.53c.04-.32.07-.64.07-.97s-.03-.66-.07-1l2.11-1.63c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.31-.61-.22l-2.49 1c-.52-.39-1.06-.73-1.69-.98l-.37-2.65A.506.506 0 0 0 14 2h-4c-.25 0-.46.18-.5.42l-.37 2.65c-.63.25-1.17.59-1.69.98l-2.49-1c-.22-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64L4.57 11c-.04.34-.07.67-.07 1s.03.65.07.97l-2.11 1.66c-.19.15-.25.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1.01c.52.4 1.06.74 1.69.99l.37 2.65c.04.24.25.42.5.42h4c.25 0 .46-.18.5-.42l.37-2.65c.63-.26 1.17-.59 1.69-.99l2.49 1.01c.22.08.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.66Z"/>
          </svg>
        </button>
      </div>
      <div class="chat-container">
        <div id="user-input-bubble">
          <!-- <div id="user-input-header">👤 You asked:</div> -->
          <div id="user-input-content"></div>
        </div>
        <div id="output">Loading Qwen3 model...</div>

        <div
          id="progress-container"
          class="progress-container"
          style="display: none"
        >
          <div class="progress-bar">
            <div id="progress-fill" class="progress-fill"></div>
          </div>
          <div id="progress-text" class="progress-text">0%</div>
        </div>

        <form id="chat-form" class="form-group">
          <div style="display: flex; gap: 0.5rem; align-items: stretch;">
            <input id="prompt" placeholder="Type your question..." disabled style="flex: 1; margin: 0;" />
            <button type="submit" disabled style="width: auto; padding: 0.8rem 1.2rem; flex-shrink: 0;">Send</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">
          <h2 class="modal-title">Settings</h2>
          <button class="close-button" id="close-modal">×</button>
        </div>
        <form id="settings-form">
          <div class="form-field">
            <label class="form-label" for="api-key">Voiceflow API Key</label>
            <div class="form-input-wrapper">
              <input type="password" id="api-key" class="form-input" placeholder="VF.DM.xxxxx..." />
              <button type="button" class="toggle-password" id="toggle-api-key" title="Show/Hide API Key">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="eye-icon">
                  <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
                </svg>
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" class="eye-slash-icon" style="display: none;">
                  <path d="M2.81 2.81L21.19 21.19l-1.41 1.41L17.85 20.67C16.31 21.52 14.24 22 12 22c-5 0-9.27-3.11-11-7.5 1.05-2.66 2.88-4.92 5.14-6.43L2.81 2.81l1.41-1.41zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01zm1.07-5.74c.33-.03.66-.05 1-.05 5 0 9.27 3.11 11 7.5-.57 1.45-1.41 2.75-2.45 3.84L20.57 12c-1.05-2.66-2.88-4.92-5.14-6.43l-1.52 1.52z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="form-field">
            <label class="form-label" for="model-select">Model</label>
            <select id="model-select" class="form-input">
              <option value="Qwen3-0.6B-q4f32_1-MLC">Qwen3 0.6B (Default - ⚡⚡⚡ | 🟢 Low | Quick responses)</option>
              <option value="SmolLM2-360M-Instruct-q4f32_1-MLC">SmolLM2-360M (⚡⚡⚡ | 🟢 Low | Ultra-lightweight)</option>
              <option value="Llama-3.2-1B-Instruct-q4f32_1-MLC">Llama 3.2 1B (⚡⚡ | 🟡 Medium | Balanced performance)</option>
              <option value="TinyLlama-1.1B-Chat-v1.0-q4f32_1-MLC">Tiny Llama (⚡⚡ | 🟡 Medium | General conversation)</option>
              <option value="Phi-3.5-mini-instruct-q4f32_1-MLC">Phi 3.5 Mini (Low ⚡ | 🟠 High | Complex reasoning)</option>
             </select>
          </div>
          <div class="form-field">
            <label class="form-label" for="chunk-limit">Chunk Limit (max 10)</label>
            <input type="number" id="chunk-limit" class="form-input" min="1" max="10" value="3" />
          </div>
          <div class="button-group">
            <button type="submit" class="form-input">Save Settings</button>
            <button type="button" id="reset-model" class="form-input button-secondary">Reload Model</button>
            <button type="button" id="clear-cache" class="form-input button-danger">Clear Cache & Re-download</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="toast-container"></div>

    <script type="module">
      import { CreateMLCEngine } from 'https://esm.run/@mlc-ai/web-llm'
      import { marked } from 'https://esm.run/marked@12.0.2'

      const output = document.getElementById('output')
      const form = document.getElementById('chat-form')
      const promptInput = document.getElementById('prompt')
      const submitButton = document.querySelector('button[type="submit"]')
      const progressContainer = document.getElementById('progress-container')
      const progressFill = document.getElementById('progress-fill')
      const progressText = document.getElementById('progress-text')
      const userInputBubble = document.getElementById('user-input-bubble')
      const userInputContent = document.getElementById('user-input-content')
      const settingsButton = document.getElementById('settings-button')
      const settingsModal = document.getElementById('settings-modal')
      const closeModal = document.getElementById('close-modal')
      const settingsForm = document.getElementById('settings-form')
      const apiKeyInput = document.getElementById('api-key')
      const chunkLimitInput = document.getElementById('chunk-limit')
      const modelSelect = document.getElementById('model-select')
      const resetModelButton = document.getElementById('reset-model')
      const clearCacheButton = document.getElementById('clear-cache')
      const toastContainer = document.getElementById('toast-container')
      const chatContainer = document.querySelector('.chat-container')
      const toggleApiKeyButton = document.getElementById('toggle-api-key')

      let engine = null
      let fullResponse = ''
      let isInThinking = false
      let thinkingTimeout = null
      let responseStarted = false // Global flag to track if response streaming has started

      // Thinking state management
      let thinkingState = {
        div: null,
        isActive: false,
        isRemoving: false
      }

      // Compact mode management
      let isCompactMode = true // Start in compact mode

      const enableCompactMode = () => {
        output.classList.add('compact')
        chatContainer.classList.add('compact')
        isCompactMode = true
      }

      const disableCompactMode = () => {
        output.classList.remove('compact')
        chatContainer.classList.remove('compact')
        isCompactMode = false
      }

      // Toast notification system
      const showToast = (message, type = 'info', duration = 4000) => {
        const toast = document.createElement('div')
        toast.className = `toast ${type}`

        const iconMap = {
          success: '✓',
          error: '✕',
          warning: '⚠',
          info: 'ℹ'
        }

        toast.innerHTML = `
          <div class="toast-icon">${iconMap[type] || iconMap.info}</div>
          <div class="toast-content">${message}</div>
          <button class="toast-close">×</button>
        `

        const closeButton = toast.querySelector('.toast-close')
        closeButton.addEventListener('click', () => removeToast(toast))

        toastContainer.appendChild(toast)

        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 10)

        // Auto remove
        setTimeout(() => removeToast(toast), duration)

        return toast
      }

      const removeToast = (toast) => {
        if (toast && toast.parentNode) {
          toast.classList.remove('show')
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast)
            }
          }, 300)
        }
      }

      // Settings management
      const getSettings = () => {
        const savedSettings = localStorage.getItem('vf-kb-settings')
        if (savedSettings) {
          try {
            return JSON.parse(savedSettings)
          } catch (e) {
            console.error('Failed to parse saved settings:', e)
          }
        }
        return {
          apiKey: null, // Default to null, user must set API key
          chunkLimit: 3,
          selectedModel: 'Qwen3-0.6B-q4f32_1-MLC' // Default model
        }
      }

      const saveSettings = (settings) => {
        try {
          localStorage.setItem('vf-kb-settings', JSON.stringify(settings))
          return true
        } catch (e) {
          console.error('Failed to save settings:', e)
          return false
        }
      }

      const loadSettingsToForm = () => {
        const settings = getSettings()
        apiKeyInput.value = settings.apiKey || ''
        chunkLimitInput.value = settings.chunkLimit
        modelSelect.value = settings.selectedModel || 'Qwen3-0.6B-q4f32_1-MLC'
      }

      const validateSettings = (apiKey, chunkLimit) => {
        const errors = []

        if (!apiKey || apiKey.trim() === '') {
          errors.push('API Key is required')
        }

        if (!chunkLimit || chunkLimit < 1 || chunkLimit > 10) {
          errors.push('Chunk Limit must be between 1 and 10')
        }

        return errors
      }

      const showSettingsModal = () => {
        loadSettingsToForm()
        settingsModal.classList.add('show')
      }

      const hideSettingsModal = () => {
        settingsModal.classList.remove('show')
      }

      // Modal event listeners
      settingsButton.addEventListener('click', showSettingsModal)
      closeModal.addEventListener('click', hideSettingsModal)

      // Close modal when clicking outside
      settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
          hideSettingsModal()
        }
      })

      // Close modal with Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsModal.classList.contains('show')) {
          hideSettingsModal()
        }
      })

      // Handle API key show/hide toggle
      toggleApiKeyButton.addEventListener('click', () => {
        const eyeIcon = toggleApiKeyButton.querySelector('.eye-icon')
        const eyeSlashIcon = toggleApiKeyButton.querySelector('.eye-slash-icon')

        if (apiKeyInput.type === 'password') {
          // Show password
          apiKeyInput.type = 'text'
          eyeIcon.style.display = 'none'
          eyeSlashIcon.style.display = 'block'
          toggleApiKeyButton.title = 'Hide API Key'
        } else {
          // Hide password
          apiKeyInput.type = 'password'
          eyeIcon.style.display = 'block'
          eyeSlashIcon.style.display = 'none'
          toggleApiKeyButton.title = 'Show API Key'
        }
      })

      // Handle settings form submission
      settingsForm.addEventListener('submit', async (e) => {
        e.preventDefault()

        const apiKey = apiKeyInput.value.trim()
        const chunkLimit = parseInt(chunkLimitInput.value)
        const selectedModel = modelSelect.value

        const errors = validateSettings(apiKey, chunkLimit)

        if (errors.length > 0) {
          showToast('Settings validation errors: ' + errors.join(', '), 'error')
          return
        }

        // Check if model has changed
        const currentSettings = getSettings()
        const modelChanged = currentSettings.selectedModel !== selectedModel

        const settings = { apiKey, chunkLimit, selectedModel }
        const saved = saveSettings(settings)

        if (saved) {
          showToast('Settings saved successfully!', 'success')
          hideSettingsModal()

          // If model changed, reload it
          if (modelChanged) {
            try {
              showToast('Model changed. Loading new model...', 'info')
              engine = null
              enableCompactMode() // Return to compact mode during model loading
              await loadModel(selectedModel)
              showToast('New model loaded successfully!', 'success')
            } catch (error) {
              showToast('Failed to load new model: ' + error.message, 'error')
            }
          }
        } else {
          showToast('Failed to save settings. Please try again.', 'error')
        }
      })

      // Handle model reset with confirmation toast
      const showConfirmationToast = (message, onConfirm, onCancel = null) => {
        const toast = document.createElement('div')
        toast.className = 'toast warning'

        toast.innerHTML = `
          <div class="toast-icon">⚠</div>
          <div class="toast-content">${message}</div>
          <div style="display: flex; gap: 0.5rem; margin-left: 0.5rem;">
            <button class="confirm-yes" style="padding: 0.25rem 0.5rem; font-size: 0.8rem; border-radius: 4px; border: 1px solid #059669; background: #10b981; color: white; cursor: pointer;">Yes</button>
            <button class="confirm-no" style="padding: 0.25rem 0.5rem; font-size: 0.8rem; border-radius: 4px; border: 1px solid #dc2626; background: #ef4444; color: white; cursor: pointer;">No</button>
          </div>
        `

        const yesButton = toast.querySelector('.confirm-yes')
        const noButton = toast.querySelector('.confirm-no')

        yesButton.addEventListener('click', () => {
          removeToast(toast)
          if (onConfirm) onConfirm()
        })

        noButton.addEventListener('click', () => {
          removeToast(toast)
          if (onCancel) onCancel()
        })

        toastContainer.appendChild(toast)
        setTimeout(() => toast.classList.add('show'), 10)

        // Auto remove after 10 seconds if no action
        setTimeout(() => removeToast(toast), 10000)

        return toast
      }

      // Handle model reset
      resetModelButton.addEventListener('click', async () => {
        showConfirmationToast(
          'Reset/reload the model? This will clear the current model and reload it.',
          async () => {
            try {
              hideSettingsModal() // Close modal to show progress
              engine = null
              enableCompactMode() // Return to compact mode
              const settings = getSettings()
              await loadModel(settings.selectedModel || 'Qwen3-0.6B-q4f32_1-MLC')
              showToast('Model reset successfully!', 'success')
            } catch (error) {
              showToast('Failed to reset model: ' + error.message, 'error')
            }
          }
        )
      })

            // Function to clear both Cache Storage and IndexedDB used by web-llm
      const clearModelCache = async () => {
        try {
          // Clear Cache Storage entries used by web-llm
          const cacheNames = await caches.keys()
          const webllmCaches = cacheNames.filter(name =>
            name.includes('webllm') ||
            name.includes('mlc') ||
            name === 'webllm/config' ||
            name === 'webllm/wasm' ||
            name === 'webllm/model'
          )

          console.log('Found cache storage entries:', webllmCaches)

          // Delete all web-llm related caches
          const cacheDeletePromises = webllmCaches.map(async (cacheName) => {
            try {
              const deleted = await caches.delete(cacheName)
              console.log(`Cache ${cacheName} deleted:`, deleted)
              return deleted
            } catch (error) {
              console.warn(`Failed to delete cache ${cacheName}:`, error)
              return false
            }
          })

          await Promise.all(cacheDeletePromises)

          // Also clear IndexedDB databases that might contain model data
          const databases = await indexedDB.databases()
          const dbPromises = databases
            .filter(db => db.name && (
              db.name.includes('webllm') ||
              db.name.includes('mlc') ||
              db.name.includes('cache') ||
              db.name.includes('model')
            ))
            .map(db => {
              return new Promise((resolve) => {
                const deleteReq = indexedDB.deleteDatabase(db.name)
                deleteReq.onsuccess = () => {
                  console.log(`Cleared IndexedDB: ${db.name}`)
                  resolve()
                }
                deleteReq.onerror = () => {
                  console.warn(`Failed to clear IndexedDB: ${db.name}`)
                  resolve() // Continue anyway
                }
                deleteReq.onblocked = () => {
                  console.warn(`IndexedDB ${db.name} deletion blocked`)
                  resolve()
                }
              })
            })

          if (dbPromises.length > 0) {
            await Promise.all(dbPromises)
          }

          // Clear any web-llm related localStorage items
          const keysToRemove = []
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i)
            if (key && (key.includes('webllm') || key.includes('mlc'))) {
              keysToRemove.push(key)
            }
          }
          keysToRemove.forEach(key => {
            console.log(`Removing localStorage key: ${key}`)
            localStorage.removeItem(key)
          })

          return true
        } catch (error) {
          console.error('Error clearing cache:', error)
          throw error
        }
      }

            // Handle cache clear and model re-download
      clearCacheButton.addEventListener('click', async () => {
        showConfirmationToast(
          'Clear all cached model data and re-download? This will delete all locally stored model files and require a fresh download.',
          async () => {
            try {
              hideSettingsModal() // Close modal to show progress
              showToast('Clearing model cache...', 'info')

              // Clear the engine first
              engine = null

              // Clear the cache
              await clearModelCache()

              showToast('Cache cleared. Starting fresh download...', 'info')

              // Return to compact mode and reload model from scratch
              enableCompactMode()
              const settings = getSettings()
              await loadModel(settings.selectedModel || 'Qwen3-0.6B-q4f32_1-MLC')

              showToast('Model cache cleared and re-downloaded successfully!', 'success')
            } catch (error) {
              showToast('Failed to clear cache and re-download model: ' + error.message, 'error')
            }
          }
        )
      })

      const updateProgress = (percent) => {
        progressContainer.style.display = 'block'
        progressFill.style.width = `${percent}%`
        progressText.textContent = `${percent}%`
      }

      const showUserInput = (content) => {
        userInputContent.textContent = content
        userInputBubble.classList.add('show')
      }

                  const showThinking = (message = "Thinking") => {
        // Remove any existing thinking indicators first
        const existingThinking = output.querySelectorAll('.thinking-indicator')
        if (existingThinking.length > 0) {
          existingThinking.forEach(el => el.remove())
        }

        // Create thinking indicator
        thinkingState.div = document.createElement('div')
        thinkingState.div.className = 'thinking-indicator'
        thinkingState.isActive = true
        thinkingState.isRemoving = false
        output.appendChild(thinkingState.div)

        // Update the message
        thinkingState.div.innerHTML = `
          <span>🤔 ${message}</span>
          <div class="thinking-dots">
            <div class="thinking-dot"></div>
            <div class="thinking-dot"></div>
            <div class="thinking-dot"></div>
          </div>
        `
        output.scrollTop = output.scrollHeight
      }

      // Keep displayThinking for compatibility with processResponseChunk
      const displayThinking = (content) => {
        // Only show thinking indicator if response hasn't started yet
        if (!responseStarted && !thinkingState.isActive) {
          showThinking("Thinking")
        }
      }

                              const removeThinking = () => {
        const existingThinking = output.querySelectorAll('.thinking-indicator')
        if (existingThinking.length > 0) {
          existingThinking.forEach(el => el.remove())
        }

        // Reset state regardless
        thinkingState.div = null
        thinkingState.isActive = false
        thinkingState.isRemoving = false
      }

      // Configure marked for better rendering
      marked.setOptions({
        breaks: false, // Disable automatic line break conversion to reduce spacing
        gfm: true
      })

      // Function to clean up markdown spacing issues
      const cleanMarkdown = (text) => {
        return text
          // Replace multiple consecutive newlines with double newlines (for paragraph breaks)
          .replace(/\n{3,}/g, '\n\n')
          // Remove trailing whitespace from lines
          .replace(/[ \t]+$/gm, '')
          // Clean up extra spaces before newlines
          .replace(/[ \t]+\n/g, '\n')
          // Remove excessive spacing around blockquotes
          .replace(/\n\n>/g, '\n>')
          .replace(/>\n\n/g, '>\n')
          // Trim start/end whitespace
          .trim()
      }

                  let cleanResponse = '' // The response without thinking tags

      const processResponseChunk = (token) => {
        fullResponse += token

        // Process the full response to extract clean content
        let processedResponse = fullResponse
        let thinkingContent = ''
        let hasThinking = false

        // Remove all complete thinking blocks and extract the last one for display
        const thinkingMatches = processedResponse.match(/<think>([\s\S]*?)<\/think>/g)
        if (thinkingMatches) {
          hasThinking = true
          // Get the content of the last thinking block
          const lastMatch = thinkingMatches[thinkingMatches.length - 1]
          thinkingContent = lastMatch.replace(/<\/?think>/g, '')

          // Remove all thinking blocks from the response
          processedResponse = processedResponse.replace(/<think>[\s\S]*?<\/think>/g, '')
        }

        // Check for incomplete thinking blocks (still streaming)
        const incompleteThinkStart = processedResponse.match(/<think>(?![\s\S]*<\/think>)([\s\S]*)$/i)
        if (incompleteThinkStart) {
          hasThinking = true
          thinkingContent = incompleteThinkStart[1]
          // Remove the incomplete thinking block
          processedResponse = processedResponse.replace(/<think>[\s\S]*$/i, '')
          isInThinking = true
        } else if (hasThinking && isInThinking) {
          // We were in thinking mode but now have complete thinking blocks
          isInThinking = false
          // Note: thinking removal is handled in the main streaming loop
        }

        // Show thinking content if we have any
        if (hasThinking && thinkingContent.trim()) {
          displayThinking(thinkingContent.trim())
        }

        // Return only the new clean content that we haven't displayed yet
        const newCleanContent = processedResponse.substring(cleanResponse.length)
        cleanResponse = processedResponse

        return newCleanContent
      }

      const loadModel = async (modelId) => {
        try {
          // Enable compact mode during loading
          enableCompactMode()

          output.textContent = 'Initializing...'
          promptInput.disabled = true
          submitButton.disabled = true
          submitButton.textContent = 'Loading Model...'
          progressContainer.style.display = 'none'

          if (!navigator.gpu) {
            throw new Error(
              'WebGPU not supported in this browser. Please use Chrome 113+, Edge 113+, or Firefox 118+.',
            )
          }

          output.textContent =
            'Starting model download. This may take a while...'

          engine = await CreateMLCEngine(modelId, {
            initProgressCallback: (progress) => {
              let percent = 0

              if (
                progress &&
                typeof progress === 'object' &&
                'progress' in progress
              ) {
                percent = Math.floor(progress.progress * 100)
              } else if (typeof progress === 'number') {
                percent = Math.floor(progress * 100)
              }

              updateProgress(percent)
              output.textContent = `Downloading model... ${percent}%`
              submitButton.textContent = `Loading... ${percent}%`
            },
            useIndexedDBCache: true,
          })

          output.textContent = 'Model ready! Ask me something!'
          promptInput.disabled = false
          submitButton.disabled = false
          submitButton.textContent = 'Send'
          progressContainer.style.display = 'none'

          // Keep compact mode in ready state - will be disabled when conversation starts

          return engine
        } catch (error) {
          output.innerHTML += `<div class="error">Failed to load model: ${error.message}</div>`
          // Reset button state on error
          submitButton.textContent = 'Send'
          submitButton.disabled = true  // Keep disabled since no model is loaded
          progressContainer.style.display = 'none'
          throw error
        }
      }

      // Function to query Voiceflow Knowledge Base
      const queryKnowledgeBase = async (question) => {
        try {
          const settings = getSettings()

          // Check if API key is set
          if (!settings.apiKey || settings.apiKey.trim() === '') {
            showToast('Please set your Voiceflow API key in Settings to query the knowledge base.', 'warning', 6000)
            return null
          }

          const response = await fetch('https://general-runtime.voiceflow.com/knowledge-base/query', {
            method: 'POST',
            headers: {
              'Authorization': settings.apiKey,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              question: question,
              synthesis: false,
              chunkLimit: settings.chunkLimit
            })
          })

          if (!response.ok) {
            if (response.status === 401) {
              showToast('Invalid API key. Please check your Voiceflow API key in Settings.', 'error')
            } else {
              showToast(`Knowledge Base API error: ${response.status}`, 'error')
            }
            throw new Error(`KB API error: ${response.status}`)
          }

          const data = await response.json()
          return data
        } catch (error) {
          console.error('Knowledge Base query failed:', error)
          if (!error.message.includes('KB API error')) {
            showToast('Failed to query knowledge base. Please try again.', 'error')
          }
          return null
        }
      }

      // Function to format KB context for LLM
      const formatKBContext = (kbData) => {
        if (!kbData || !kbData.chunks || kbData.chunks.length === 0) {
          return null
        }

        let context = "Based on the following knowledge base information:\n\n"

        kbData.chunks.forEach((chunk, index) => {
          context += `Context ${index + 1} (Relevance: ${Math.round(chunk.score * 100)}%):\n`
          context += `${chunk.content}\n\n`
        })

        context += "Please answer the user's question using only the information provided above. If the information doesn't contain the answer, please say so."

        return context
      }

      // Add Enter key support
      promptInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault()
          if (!promptInput.disabled && !submitButton.disabled && promptInput.value.trim()) {
            form.dispatchEvent(new Event('submit'))
          }
        }
      })

      form.addEventListener('submit', async (e) => {
        e.preventDefault()

        // Prevent submission if button is disabled (e.g., during model loading)
        if (submitButton.disabled) {
          return
        }

        if (!engine) {
          output.innerHTML += `<div class="error">No model loaded. Please load a model first.</div>`
          return
        }

        const prompt = promptInput.value.trim()
        if (!prompt) return

        // Disable compact mode when conversation starts
        if (isCompactMode) {
          disableCompactMode()
        }

        // Reset response tracking variables
        fullResponse = ''
        cleanResponse = ''
        isInThinking = false
        responseStarted = false // Reset response tracking

        // Reset thinking state
        thinkingState.div = null
        thinkingState.isActive = false
        thinkingState.isRemoving = false

        // Show user input in the separate bubble
        showUserInput(prompt)

        // Clear the main output and prepare for assistant response
        output.innerHTML = ''
        promptInput.value = ''
        promptInput.disabled = true
        submitButton.disabled = true

        try {
          let kbData = null

          // Check if input is short (less than 12 characters)
          if (prompt.length < 15) {
            // Show info message for short inputs
            showToast('💡 For better knowledge base results, try asking a more detailed question!', 'info', 5000)

            // Skip KB query and go directly to thinking
            showThinking("Thinking")
          } else {
            // Show documentation search animation for normal length inputs
            showThinking("Searching documentation")

            // Query the Knowledge Base for detailed questions
            kbData = await queryKnowledgeBase(prompt)

            // Switch to thinking animation immediately after KB query
            removeThinking() // Clean removal of search indicator
            showThinking("Thinking") // Show thinking for LLM processing
          }

          // Add a safety timeout only as a last resort
          const safetyTimeout = setTimeout(() => {
            removeThinking()
          }, 15000) // 15 second safety timeout to account for thinking process

          let messages = []

          if (kbData && kbData.chunks && kbData.chunks.length > 0) {
            // Format the context for the LLM
            const context = formatKBContext(kbData)

            // Create system message with context and user question
            messages = [
              {
                role: 'system',
                content: context
              },
              {
                role: 'user',
                content: prompt
              }
            ]
          } else {
            messages = [{ role: 'user', content: prompt }]
          }

          const stream = await engine.chat.completions.create({
            messages: messages,
            stream: true,
          })

          let accumulatedMarkdown = ''
          let isFirstToken = true

                              for await (const chunk of stream) {
            const token = chunk.choices[0].delta.content || ''
            const displayToken = processResponseChunk(token)

            // Remove thinking indicator only when we get displayable content (not thinking blocks)
            if (!responseStarted && displayToken && displayToken.trim()) {
              clearTimeout(safetyTimeout)
              removeThinking()
              responseStarted = true
            }

                        if (displayToken && isFirstToken) {
              // Create assistant response container
              const assistantResponseDiv = document.createElement('div')
              assistantResponseDiv.className = 'assistant-response'
              output.appendChild(assistantResponseDiv)

              isFirstToken = false
            }

            if (displayToken) {
              accumulatedMarkdown += displayToken
              const assistantResponseDiv = output.querySelector('.assistant-response')
              if (assistantResponseDiv) {
                // Clean and render the accumulated markdown
                const cleanedMarkdown = cleanMarkdown(accumulatedMarkdown)
                assistantResponseDiv.innerHTML = marked.parse(cleanedMarkdown)
                output.scrollTop = output.scrollHeight
              }
            }
          }

          // Final cleanup - clear timeout only
          clearTimeout(safetyTimeout)

          promptInput.disabled = false
          submitButton.disabled = false
          promptInput.focus()
        } catch (error) {
          // Ensure thinking is removed on any error
          clearTimeout(safetyTimeout)
          removeThinking()
          output.innerHTML += `<div class="error">Error during chat: ${error.message}</div>`
          promptInput.disabled = false
          submitButton.disabled = false
        }
      })

            // Auto-load the selected model on page load
      window.addEventListener('load', async () => {
        try {
          // Start in compact mode
          enableCompactMode()

          // Get saved model preference or use default
          const settings = getSettings()
          const modelToLoad = settings.selectedModel || 'Qwen3-0.6B-q4f32_1-MLC'
          await loadModel(modelToLoad)

          // Check if user needs to set API key
          if (!settings.apiKey || settings.apiKey.trim() === '') {
            setTimeout(() => {
              showToast('👋 Welcome! Please click the gear icon to set your Voiceflow API key for knowledge base queries.', 'info', 8000)
            }, 2000) // Show after 2 seconds to not overlap with model loading
          }
        } catch (error) {
          console.error('Failed to auto-load model:', error)
        }
      })
    </script>
  </body>
</html>
